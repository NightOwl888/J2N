<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ArgumentNull_CollectionDoesntSupportNull" xml:space="preserve">
    <value>The collection does not support null values.</value>
  </data>
  <data name="ArgumentOutOfRange_BiggerThanCollection" xml:space="preserve">
    <value>Must be less than or equal to the size of the collection.</value>
  </data>
  <data name="ArgumentOutOfRange_Count" xml:space="preserve">
    <value>Count must be positive and count must refer to a location within the string/array/collection.</value>
  </data>
  <data name="ArgumentOutOfRange_Generic_MustBeNonNegative" xml:space="preserve">
    <value>{0} ('{1}') must be a non-negative value.</value>
  </data>
  <data name="ArgumentOutOfRange_Index" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than the size of the string/array/collection.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexBefore" xml:space="preserve">
    <value>Index was out of range. Must be at least 1 and less than or equal to the size of the string/array/collection.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexLength" xml:space="preserve">
    <value>Index and length must refer to a location within the string.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexMustBeLessOrEqual" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than or equal to the size of the collection.</value>
  </data>
  <data name="ArgumentOutOfRange_ListInsert" xml:space="preserve">
    <value>Index must be within the bounds of the List.</value>
  </data>
  <data name="ArgumentOutOfRange_NeedNonNegNum" xml:space="preserve">
    <value>Non-negative number required.</value>
  </data>
  <data name="ArgumentOutOfRange_Radix" xml:space="preserve">
    <value>Radix must be greater than or equal to Character.MinRadix and less than or equal to Character.MaxRadix.</value>
  </data>
  <data name="ArgumentOutOfRange_SmallCapacity" xml:space="preserve">
    <value>capacity was less than the current size.</value>
  </data>
  <data name="Argument_AddingDuplicate" xml:space="preserve">
    <value>An item with the same key has already been added. Key: {0}</value>
  </data>
  <data name="Argument_ArrayTooLarge" xml:space="preserve">
    <value>The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.</value>
  </data>
  <data name="Argument_BadFormatSpecifier" xml:space="preserve">
    <value>Format specifier was invalid.</value>
  </data>
  <data name="Argument_CollectionMustNotBeThis" xml:space="preserve">
    <value>collection must not be the same instance as this.</value>
  </data>
  <data name="Argument_DestinationTooShort" xml:space="preserve">
    <value>Destination is too short.</value>
  </data>
  <data name="Argument_InvalidArgumentForComparison" xml:space="preserve">
    <value>Type of argument is not compatible with the generic comparer.</value>
  </data>
  <data name="Argument_InvalidCodePoint" xml:space="preserve">
    <value>'{0}' is not a valid Unicode code point.</value>
  </data>
  <data name="Argument_InvalidNumberStyle" xml:space="preserve">
    <value>An undefined NumberStyle value is being used: {0}.</value>
  </data>
  <data name="Argument_InvalidOffLen" xml:space="preserve">
    <value>Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.</value>
  </data>
  <data name="Argument_MinMaxValue" xml:space="preserve">
    <value>'{0}' cannot be greater than {1}.</value>
  </data>
  <data name="Argument_MustBePrimitiveType" xml:space="preserve">
    <value>'{0}' is not a primitive type.</value>
  </data>
  <data name="Argument_MustNotBeThis" xml:space="preserve">
    <value>'{0}' must not be the same instance as this.</value>
  </data>
  <data name="Argument_TypeOfKeyIncorrect" xml:space="preserve">
    <value>The key was of an incorrect type for this dictionary.</value>
  </data>
  <data name="Argument_TypeOfValueIncorrect" xml:space="preserve">
    <value>The value was of an incorrect type for this dictionary.</value>
  </data>
  <data name="Arg_ArrayLengthsDiffer" xml:space="preserve">
    <value>Array lengths must be the same.</value>
  </data>
  <data name="Arg_ArrayPlusOffTooSmall" xml:space="preserve">
    <value>Destination array is not long enough to copy all the items in the collection. Check array index and length.</value>
  </data>
  <data name="Arg_BitArrayTypeUnsupported" xml:space="preserve">
    <value>Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].</value>
  </data>
  <data name="Arg_BogusIComparer" xml:space="preserve">
    <value>Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.</value>
  </data>
  <data name="Arg_ExponentRequiredIfTypeSpecifierUsed" xml:space="preserve">
    <value>With the AllowHexSpecifier and AllowTypeSpecifier bits set in the enum bit field, the parser is unable to distinguish between a type specifier d, D, f, or F and a hexadecimal digit. Therefore, AllowExponent is also required to delineate between hexadecimal digits and type specifier and an exponent must be supplied if type specifier d, D, f, or F is used.</value>
  </data>
  <data name="Arg_HSCapacityOverflow" xml:space="preserve">
    <value>HashSet capacity is too big.</value>
  </data>
  <data name="Arg_HTCapacityOverflow" xml:space="preserve">
    <value>Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.</value>
  </data>
  <data name="Arg_InsufficientSpace" xml:space="preserve">
    <value>Insufficient space in the target location to copy the information.</value>
  </data>
  <data name="Arg_InvalidANSIString" xml:space="preserve">
    <value>The ANSI string passed in could not be converted from the default ANSI code page to Unicode.</value>
  </data>
  <data name="Arg_InvalidHexFloatStyle" xml:space="preserve">
    <value>With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexFloat or AllowTypeSpecifier. The bit(s) '{0}' were also specified, which are not allowed.</value>
  </data>
  <data name="Arg_InvalidHexStyle" xml:space="preserve">
    <value>With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber. The bit(s) '{0}' were also specified, which are not allowed.</value>
  </data>
  <data name="Arg_KeyNotFoundWithKey" xml:space="preserve">
    <value>The given key '{0}' was not present in the dictionary.</value>
  </data>
  <data name="Arg_LongerThanSrcString" xml:space="preserve">
    <value>Source string was not long enough. Check sourceIndex and count.</value>
  </data>
  <data name="Arg_MustBeByte" xml:space="preserve">
    <value>Object must be of type Byte.</value>
  </data>
  <data name="Arg_MustBeDouble" xml:space="preserve">
    <value>Object must be of type Double.</value>
  </data>
  <data name="Arg_MustBeInt16" xml:space="preserve">
    <value>Object must be of type Int16.</value>
  </data>
  <data name="Arg_MustBeInt32" xml:space="preserve">
    <value>Object must be of type Int32.</value>
  </data>
  <data name="Arg_MustBeInt64" xml:space="preserve">
    <value>Object must be of type Int16.</value>
  </data>
  <data name="Arg_MustBeSByte" xml:space="preserve">
    <value>Object must be of type SByte.</value>
  </data>
  <data name="Arg_MustBeSingle" xml:space="preserve">
    <value>Object must be of type Single.</value>
  </data>
  <data name="Arg_Need1DArray" xml:space="preserve">
    <value>Array was not a one-dimensional array.</value>
  </data>
  <data name="Arg_NonZeroLowerBound" xml:space="preserve">
    <value>The lower bound of target array must be zero.</value>
  </data>
  <data name="Arg_RankMultiDimNotSupported" xml:space="preserve">
    <value>Only single dimensional arrays are supported for the requested action.</value>
  </data>
  <data name="Arg_TypeSpecifierNotAllowedIfCurrencyUsed" xml:space="preserve">
    <value>The AllowCurrencySymbol bit and AllowTypeSpecifier bit may not be combined.</value>
  </data>
  <data name="Arg_WrongType" xml:space="preserve">
    <value>The value '{0}' is not of type '{1}' and cannot be used in this generic collection.</value>
  </data>
  <data name="ConcurrentCollection_SyncRoot_NotSupported" xml:space="preserve">
    <value>The SyncRoot property may not be used for the synchronization of concurrent collections.</value>
  </data>
  <data name="ExternalLinkedListNode" xml:space="preserve">
    <value>The LinkedList node does not belong to current LinkedList.</value>
  </data>
  <data name="Format_EmptyInputString" xml:space="preserve">
    <value>Input string was either empty or contained only whitespace.</value>
  </data>
  <data name="Format_ExtraJunkAtEnd" xml:space="preserve">
    <value>Additional non-parsable characters are at the end of the string.</value>
  </data>
  <data name="Format_InvalidString" xml:space="preserve">
    <value>Input string was not in a correct format. Value: '{0}'.</value>
  </data>
  <data name="Format_InvalidUTFSpec2ndByte" xml:space="preserve">
    <value>Second byte at {0} does not match UTF8 Specification.</value>
  </data>
  <data name="Format_InvalidUTFSpec2ndOr3rdByte" xml:space="preserve">
    <value>Second or third byte at {0} does not match UTF8 Specification.</value>
  </data>
  <data name="Format_InvalidUTFSpec3rdByte" xml:space="preserve">
    <value>Third byte at {0} does not match UTF8 Specification.</value>
  </data>
  <data name="Format_InvalidUTFSpecInput" xml:space="preserve">
    <value>Input at {0} does not match UTF8 Specification.</value>
  </data>
  <data name="Format_InvalidUTFTooLong" xml:space="preserve">
    <value>UTF8 data format too long.</value>
  </data>
  <data name="Format_NoParsibleDigits" xml:space="preserve">
    <value>Could not find any recognizable digits.</value>
  </data>
  <data name="InvalidCast_DBNull" xml:space="preserve">
    <value>Object cannot be cast to DBNull.</value>
  </data>
  <data name="InvalidCast_Empty" xml:space="preserve">
    <value>Object cannot be cast to Empty.</value>
  </data>
  <data name="InvalidCast_FromTo" xml:space="preserve">
    <value>Invalid cast from '{0}' to '{1}'.</value>
  </data>
  <data name="InvalidOperation_CannotEditNullObject" xml:space="preserve">
    <value>Cannot edit a null {0}.</value>
  </data>
  <data name="InvalidOperation_CannotIndexNullObject" xml:space="preserve">
    <value>Cannot index a null {0}.</value>
  </data>
  <data name="InvalidOperation_CollectionCorrupted" xml:space="preserve">
    <value>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</value>
  </data>
  <data name="InvalidOperation_ComparerRequired" xml:space="preserve">
    <value>Either an IComparer&lt;T&gt; must be supplied via a constructor, or the generic closing type must implement IComparable&lt;T&gt;.</value>
  </data>
  <data name="InvalidOperation_ConcurrentOperationsNotSupported" xml:space="preserve">
    <value>Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.</value>
  </data>
  <data name="InvalidOperation_EmptyQueue" xml:space="preserve">
    <value>Queue empty.</value>
  </data>
  <data name="InvalidOperation_EmptyStack" xml:space="preserve">
    <value>Stack empty.</value>
  </data>
  <data name="InvalidOperation_EnumEnded" xml:space="preserve">
    <value>Enumeration already finished.</value>
  </data>
  <data name="InvalidOperation_EnumFailedVersion" xml:space="preserve">
    <value>Collection was modified after the enumerator was instantiated.</value>
  </data>
  <data name="InvalidOperation_EnumNotStarted" xml:space="preserve">
    <value>Enumeration has not started. Call MoveNext.</value>
  </data>
  <data name="InvalidOperation_EnumOpCantHappen" xml:space="preserve">
    <value>Enumeration has either not started or has already finished.</value>
  </data>
  <data name="InvalidOperation_IComparerFailed" xml:space="preserve">
    <value>Failed to compare two elements in the array.</value>
  </data>
  <data name="InvalidOperation_ViewFailedVersion" xml:space="preserve">
    <value>Ancestral collection was modified after the view was instantiated.</value>
  </data>
  <data name="LinkedListEmpty" xml:space="preserve">
    <value>The LinkedList is empty.</value>
  </data>
  <data name="LinkedListNodeIsAttached" xml:space="preserve">
    <value>The LinkedList node already belongs to a LinkedList.</value>
  </data>
  <data name="LurchTable_CorruptedData" xml:space="preserve">
    <value>The LurchTable internal datastructure appears to be corrupted.</value>
  </data>
  <data name="LurchTable_NeedLimitIntMaxValue" xml:space="preserve">
    <value>For an unordered LurchTable (LurchTableOrder.None), the limit must be set to int.MaxValue.</value>
  </data>
  <data name="NotSupported_KeyCollectionSet" xml:space="preserve">
    <value>Mutating a key collection derived from a dictionary is not allowed.</value>
  </data>
  <data name="NotSupported_ReadOnlyCollection" xml:space="preserve">
    <value>Collection is read-only.</value>
  </data>
  <data name="NotSupported_SortedListNestedWrite" xml:space="preserve">
    <value>This operation is not supported on SortedList nested types because they require modifying the original SortedList.</value>
  </data>
  <data name="NotSupported_ValueCollectionSet" xml:space="preserve">
    <value>Mutating a value collection derived from a dictionary is not allowed.</value>
  </data>
  <data name="Overflow_Byte" xml:space="preserve">
    <value>Value was either too large or too small for an unsigned byte.</value>
  </data>
  <data name="Overflow_Decimal" xml:space="preserve">
    <value>Value was either too large or too small for a Decimal.</value>
  </data>
  <data name="Overflow_Int16" xml:space="preserve">
    <value>Value was either too large or too small for an Int16.</value>
  </data>
  <data name="Overflow_Int32" xml:space="preserve">
    <value>Value was either too large or too small for an Int32.</value>
  </data>
  <data name="Overflow_Int64" xml:space="preserve">
    <value>Value was either too large or too small for an Int64.</value>
  </data>
  <data name="Overflow_NegativeUnsigned" xml:space="preserve">
    <value>The string was being parsed as an unsigned number and could not have a negative sign.</value>
  </data>
  <data name="Overflow_SByte" xml:space="preserve">
    <value>Value was either too large or too small for a signed byte.</value>
  </data>
  <data name="Overflow_UInt16" xml:space="preserve">
    <value>Value was either too large or too small for a UInt16.</value>
  </data>
  <data name="Overflow_UInt32" xml:space="preserve">
    <value>Value was either too large or too small for a UInt32.</value>
  </data>
  <data name="Overflow_UInt64" xml:space="preserve">
    <value>Value was either too large or too small for a UInt64.</value>
  </data>
  <data name="Serialization_InvalidOnDeser" xml:space="preserve">
    <value>OnDeserialization method was called while the object was not being deserialized.</value>
  </data>
  <data name="Serialization_MismatchedCount" xml:space="preserve">
    <value>The serialized Count information doesn't match the number of items.</value>
  </data>
  <data name="Serialization_MissingKeys" xml:space="preserve">
    <value>The keys for this dictionary are missing.</value>
  </data>
  <data name="Serialization_MissingValues" xml:space="preserve">
    <value>The values for this dictionary are missing.</value>
  </data>
  <data name="SortedSet_LowerValueGreaterThanUpperValue" xml:space="preserve">
    <value>Must be less than or equal to upperValue.</value>
  </data>
  <data name="ArgumentNull_NullOrNullValue" xml:space="preserve">
    <value>Value cannot be null or wrap a null value.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexMustBeLess" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than the size of the collection.</value>
  </data>
  <data name="ArgumentOutOfRange_OffsetOut" xml:space="preserve">
    <value>Either offset did not refer to a position in the string, or there is an insufficient length of destination character array.</value>
  </data>
  <data name="ArgumentOutOfRange_StartIndexLargerThanLength" xml:space="preserve">
    <value>startIndex cannot be larger than length of string.</value>
  </data>
  <data name="Arg_EmptySpan" xml:space="preserve">
    <value>Span may not be empty.</value>
  </data>
  <data name="ArgumentOutOfRange_Capacity" xml:space="preserve">
    <value>Capacity exceeds maximum capacity.</value>
  </data>
  <data name="ArgumentOutOfRange_Generic_MustBeNonNegativeNonZero" xml:space="preserve">
    <value>{0} ('{1}') must be a non-negative and non-zero value.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexLengthArray" xml:space="preserve">
    <value>Index and length must refer to a location within the array.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexLengthBuffer" xml:space="preserve">
    <value>Index and length must refer to a location within the buffer.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexString" xml:space="preserve">
    <value>Index was out of range. Must be non-negative and less than the length of the string.</value>
  </data>
  <data name="ArgumentOutOfRange_IndexCount" xml:space="preserve">
    <value>Index and count must refer to a location within the string.</value>
  </data>
  <data name="Argument_IncompatibleArrayType" xml:space="preserve">
    <value>Target array type is not compatible with the type of items in the collection.</value>
  </data>
  <data name="ArgumentOutOfRange_PositionMustBeLessThanLimit" xml:space="preserve">
    <value>Value was out of range. Position must be non-negative and less than Limit.</value>
  </data>
  <data name="ArgumentOutOfRange_LimitMustBeLessThanCapacity" xml:space="preserve">
    <value>Value was out of range. Limit must be non-negative and less than Capacity.</value>
  </data>
</root>